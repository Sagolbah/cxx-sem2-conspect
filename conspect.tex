\documentclass[15pt, a4paper]{article}
\usepackage[utf8]{inputenc} % если ваш файл содержит русский текст, нужно указать кодировку
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel} % для того, чтобы писать русский текст
\usepackage{amsmath} % для команды equation*
\usepackage{hyperref} % для вставки ссылок
\usepackage{graphicx}
\usepackage[russian]{babel}
\parindent 0pt
\parskip 0pt
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{array}
\usepackage[left=2.3cm, right=3.3cm, top=1.7cm, bottom=1.7cm, bindingoffset=0cm]{geometry}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{float}
\usepackage{enumitem}
\usepackage{array}
\usepackage{subcaption}
\usepackage{multicol}
\usepackage{fancyhdr} 
\usepackage{extramarks}
\usepackage{todonotes}
\usepackage{color}
\graphicspath{{pictures/}}
\usepackage{lipsum}                     % Dummytext
\usepackage{xargs}                      % Use more than one optional parameter in a new commands
\usepackage{xcolor}
\usepackage[normalem]{ulem}
\usepackage{setspace}
\onehalfspacing

\title{C++ year2018, семестр 2}
\author{github.com/Sagolbah/cxx-sem2-conspect}
\date{\today}

\pagestyle{fancy}
\fancyhf{}
\lhead{Sorokin: CT Writes LGD Twice}
\chead{C++ y2018 sem2}
\rhead{\thepage}
\lfoot{github.com/Sagolbah/cxx-sem2-conspect}
\cfoot{}
\rfoot{\today}
\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}
\newcommand{\nl}{\newline}
\newcommand{\intba}{\int^b_a}


\setenumerate{topsep=0ex,itemsep=0ex,partopsep=0ex,parsep=0ex}

\begin{document}
	\section{Клуб фанатов Manowar}
	\begin{enumerate}
		\item Каждая секция - отдельная тема у Сорокина (sorokin.github.io/cpp-course).
		\item Для списков используйте \verb|\begin{enumerate}| или \verb|\begin{itemize}| 
		\item Очень помогает latex cheatsheet.
        \item Первые пять билетов пропущены - там асм и прочая дичь. Пока что в приоритете билеты по плюсам.
        \item Может попасться всё до 19 билета включительно.
        \item Писать максимально подробно по каждому пункту - мало ли, что могут спросить.
        \item Я заменил "Билет" на "Лекции". Так корректнее (билетов на экзамене как таковых нет - будут рандомные вопросы по лекциям. При этом лекции 1-5 попадаются редко.)
    \end{enumerate}
 
    \section{Лекция 6}
    \subsection{Структуры}
    С помощью структур можно создавать пользовательские типы. По дефолту все поля структуры публичны,
    в то время как поля классов по дефолту приватны. \nl
    Доступ к полям структур осуществляется через оператор \texttt{.}, для указателей на структуры используется
    оператор \texttt{->}.
    \begin{verbatim}
        struct point {
        	double x;
            double y;
        };
        ...
        point p = {11.4514, 810.931};
        p.x = -19.19;
        point * pp = new point;
        pp->y = 4545;
    \end{verbatim}
    Инициализировать структуры можно, прописав фигурные скобки. \nl
    Методы $-$ функции, определяемые в полях структур (non C-style). Они  реализованы с неявным параметром
    \texttt{this}, который является указателем на текущий экземпляр структуры.
    Объявдение и определение методов:
    \begin{verbatim}
    	struct point {
        	// declaration
        	void shift(double x, double y);
        	double x;
            double y;
        };
        ...
        // definition
        void point::shift(double x, double y) {...}        
    \end{verbatim}
    Определение структуры не генерирует никакого кода на ассемблере. Структуры существуют только на
    момент компиляции, они определяют то, как данные адресуются в памяти и располагаются, но после того,
    как код скомпилировался, никакой информации о структурах уже нет. \nl
    Конструкторы $-$ методы для инициализации структур.
    \begin{verbatim}
        	point() {x = y=  0;}
            point(double x, double y) {
            	this->x = x;
                this->y = y;
            }
        ...
        // empty constructor call
        point p1;
        // calling constructor with 2 args
        point p2(1, 2);
    \end{verbatim}
    Список инициализации позволяет проинициализировать поле до входа в тело конструктора. Инициализация
    полей в списке инициализации происходит в порядке объявления полей. То есть при написании \texttt{y(0),
    x(y)} произойдёт не то, что ожидалось.
    \begin{verbatim}
        	point() : x(0), y(0) {}
            point(double x, double y) : x(x), y(y) {}
    \end{verbatim}
    В функциях можно определить значения по умолчанию.
    \begin{verbatim}
    	point(double x = 0, double y = 0) : x(x), y(y) {}
        ...
        point p1; // x = 0, y = 0
        point p2(2); // x = 2, y = 0
        point p3(3, 4); // x = 3, y = 4
    \end{verbatim}
    Конструктор одного параметра задаёт неявное пользовательское преобразование. Запретить это можно при
    помощи ключевого слова \texttt{explicit}.
    \begin{verbatim}
    	explicit point(double x = 0, double y = 0) : x(x), y(y) {}
        ...
        point p = 2; // error
    \end{verbatim}
    Конструктор по умолчанию генерируется компилятором, если он пользовательски не задан.
    \begin{verbatim}
    	struct segment {
        	segment(point p1, point p2) : p1(p1), p2(p2) {}
            point p1;
            point p2;
        };
        ...
        segment s; // error
    \end{verbatim}
    Деструктор $-$ метод, вызывающийся при удалении структуры и по умолчанию генерируется компилятором.
    У него может быть только 0 аргументов, и он всегда один на одну структуру. Объявляется как \texttt{\~<struct
    name>}.\nl
    Конструкторы и деструктор позволяют чётко определять время жизни структуры. Обращение к некоторым
    значениям до вызова конструктора или после вызова деструктора приводит к undefined behavior.
    \newpage
    \subsection{Указатели, адреса, массивы и их друзья}
    Память компьютера (спасибо SKKV'у) - это последовательность ячеек, пронумерованных от $0$ до $2^n-1$. Всё, что в ней расположено,
    имеет свой адрес. Тип данных, хранящий адрес на объект типа $t$ называется указателем на $t$:
    \begin{verbatim}
        int a = 666;
        int *ptr = &a; // *a = 666, унарный & - оператор взятия адреса в памяти.      
    \end{verbatim} 
    Например, если наша переменная лежала в участке памяти, \textbf{первая} ячейка которого имеет номер $1337228$, указатель будет хранить число $1337228$.
    Из коммента к примеру видно, что унарный $*$ - это оператор разыменовывания. Кроме того, можно разыменовывать указатель и делать присваивание:
    \begin{verbatim}
        char ch = 'a', ch2 = 'q';
        char *ptr = &ch;
        char *ptr2 = &ch2;
        *ptr = 'b';  // OK, ch = 'b'.
        *ptr = *ptr2; // OK, ch = 'q', ch2 = 'q'
        int* fail = &ch2; // CE, нельзя присваивать int* char*
        int* rr = new int(8);
        delete rr;
        *rr = 111; // ОЖВП
    \end{verbatim}
    Массивы - это, по сути своей, последовательность объектов. Они расположены в соседствующих ячейках. В качестве синтаксического сахара существует оператор $[]$. \nl
    \textbf{NB:} размер статического массива определяется на этапе компиляции.
    \begin{verbatim}
        int arr[10];
        int* qqq = arr; // ОК, массив, по сути, это и есть указатель.
        arr[0] = 12, arr[1] = -15, arr[2] = 666;
        printf("%d", *arr); // напечатает первый элемент, указатель хранит именно его.
        *(arr + 2) = 20; // arr[2] = 20.
        arr[1] = 100;
        *(arr + 1) = 100; // это эквивалентный код. 
        arr[-1] = 1349; // i am not in danger, i AM the danger.
        // RTE такое не выкинет, осторожно!
        arr[5] = 88888;
        int *ptr = &arr[5]; // OK, указатели могут ссылаться на элементы массива.
        *ptr = 102; // OK, arr[5] = 102
    \end{verbatim}
    Из примера выше: в арифметике указателей не требуется домножать на $sizeof(type)$. Инкремент указателя на $int$, например, увеличит адрес
    на 4, а не на 1, так как $sizeof(int) = 4$. Декремент работает аналогично, но уменьшает адрес. Примеры с арифметикой: 
    \begin{verbatim}
        int arr[10];
        int *ptr = arr;
        *(++ptr) = 1214; // OK, arr[1] = 1214, внимание на приоритет операций.
        int *ptr2 = &arr[8];
        printf("%d", ptr2 - ptr); // OK, выведется 7.
        auto bye = ptr + ptr2; // CE, складывать нельзя.
        for (int *i = &arr[0]; i<&arr[10]; ++i) printf("%d ", *i); // OK, выведет arr.
    \end{verbatim}
    Ещё есть тип $*void$, он юзается для указателей на ячейку памяти, тип которой неизвестен. Пример юзания - передача адреса из одной части программы в другую. \nl
    Указатели на функции:
    \begin{verbatim}
        int foo(){
            return 102;
        }
        double square(double a){
            return a*a;
        }    
        int area(int a, int b){
            return a*b;
        }
        int (*ptr)() = foo; // OK. Внимание - тут неявная конвертация
        // NB: если бы у нас была ф-ия сортировки с аргументом - указатель на функцию 
        // компаратора (int* arr, bool (*comparator)(int, int))
        // и компаратор cmp где-нибудь сверху, можно было бы написать sort(arr, cmp);
        int (*ptr2)() = square; // CE, разные типы возврата
        double(*ptr2)() = square; // CE, не те аргументы
        double(*ptr2)(double) = square; // OK
        int (*ptr3)(int, int) = area; // OK
        // вызов функций:
        std::cout << (*ptr)() << "\n"; // 102
        std::cout << (*ptr2)(13.22) << "\n"; // 174.168
        std::cout << (*ptr3)(12, 22) << "\n"; // 264
    \end{verbatim}
    Такой уродский синтаксис обусловлен приоритетом операций. В противном случае код int *ptr() будет прочтён как предварительное объявление
    функции $ptr()$, которая ничего не принимает и возвращает указатель на $int$. \nl
    И немного о ссылках: это, по сути, автоматически разыменовываемый константный указатель.
    \begin{verbatim}
        int t = 10;
        int &link = t;
        link = 666; // t = 666
        int a = 124124;
        link = &a; // CE
    \end{verbatim}
    \newpage

    \section{Лекции 7/8}
    \subsection{Процесс компиляции программ}
    \begin{enumerate}
        \item Препроцессинг. \nl
        На этой стадии происходит работа с директивами препроцессора. Например, \texttt{\#include}, \texttt{\#define}, \texttt{\#ifndef}.    
        Хэдеры, включённые через \texttt{\#include} проходят препроцессинг рекурсивно. При помощи флага $-E$ можно получить файл без компиляции, но с препроцессингом. \nl
        \texttt{g++ -E A.cpp -o A.ii} - здесь A.ii это .cpp файл после препроцессинга.
        \item Получение ассемблерного кода. \nl
        Здесь плюсовый код превращается в ассемблерный (но ещё не машинный). При помощи флага $-S$ можно получить ассемблерный код:
        \texttt{g++ -S A.cpp -o A.s}
        \item Получение машинного кода. \nl
        Здесь тексты на языке ассемблера превращаются в объектные файлы. Объектный файл содержит кусок машинного кода, который ещё не связан с остальными кусками кода в единую программу.
        Простейший пример - определение полей класса в одном файле, а объявление - в другом. Именно для объединения их и существует следующая стадия.
        Получить машинный код с помощью асма AT\&T можно так: \texttt{as A.s -o A.o}
        \item Линковка. \nl
        Здесь все объектные файлы и статические либы связываются в единый исполняемый файл, который мы и используем.
        Для линковки используется таблица символов. Это генерируемая компилятором структура данных, хранящая имена функций, объектов итд,
        где каждому идентификатору (символу) соотносятся его тип и область видимости. В ней также хранятся адреса ссылок на данные и прочее в других объектных файлах
        Благодаря этой таблице линковщик строит связи между данными в различных оюъектных файлах, собирая из них единый исполняемый файл / библиотеку. \nl
        \textbf{NB:} Единицей трансляции называется подаваемый на вход компилятору исходник со всеми включёнными в него файлами. Судя по англовики, это то, что получается после первой стадии.
    \end{enumerate}
    \subsection{declaration/definition}
    Объявление вводит переменную/функцию в область видимости, устанавливает её тип и, опционально, инициализирует её.
    Пока имя не объявлено, его использовать, очевидно, нельзя. Объявление, которое полностью описывает объявлённую сущность (переменная/функция/etc) называется определением.
    \begin{verbatim}
        double square(double); // declaration функции
        extern int tmp; // declaration (defined by garbage value)
        int def = 98; // declaration (and definition)
        int square(double); // очевидный CE.
        
        double square(double k){
            return k*k;
        } // definition of declared "square"

        // cycling:

        double f(int a){
            return g(a-1) - 44;
        }

        double g(int a){
            if (a > 1) return f(a-29) + 151;
            return 9;
        }   // цикл определений, чтобы спастись, нужно заранее объявить функции
        // struct def/decl:

        struct point;

        struct point {int x; int y;};

        struct cycle{
            cycle a; // CE
            cycle *a; // OK
        };
    \end{verbatim}
    \subsection{static, headers, header-guard (карты, деньги, два ствола)}
    Модификатор \texttt{static} работает как в жаве - это \textbf{общее} поле для всех экземпляров класса. Можно обратиться извне (если публичный) при помощи двух двоеточий.
    Использование $static$ по отношению к члену класса гарантирует, что в программе будет ровно одна копия его значения (а не по копии на каждый объект).
    Статические переменные в функциях создаются и инициализируются только один раз, а после выхода из области видимости - не сгорают. Тем не менее, к ним можно обратиться только из их области видимости.
    Статические методы классов не принимают this и могут обращаться только к static полям. \nl
    \textbf{NB:} Статические функции и переменные в \textbf{глобальной видимости} не проходят внешнюю линковку - из сторонних файлов их не увидеть.
    \begin{verbatim}
        void foo(){
            static int a = 1;
            ++a;
            printf("%d\n", a);
        }
        int main(){
            foo(); // 2
            foo(); // 3
            foo(); // 4
            a = 666; // CE, нет в области видимости.
        }
    \end{verbatim}
    Заголовки позволяют программисту контролировать определения и объединения. В хэдерах записывают объявления, а затем их можно помещать при помощи $\# include$.
    В С++ принята следующая практика (на примере): в $sample.h$ файле собраны объявления, а $sample.cpp$ - инклудит хэдер и определяет поля. Например, в $calc.h$ объявлена
    функция $ln$, а в $.cpp$ - эта функция реализуется. Позже в другом файле сделать \texttt{\#include "sample.h"} и пользоваться той же функцией $ln$. \nl 
    Однако, есть одна проблема. Директивка \texttt{\#include} тупо копипастит содержимое другого файла в исходник. Поэтому может возникнуть такое:
    \begin{verbatim}
        // A.cpp
        struct A{
            void foo();
        };
        // B.cpp
        #include "A.cpp"
        struct B{};
        // C.cpp
        #include "A.cpp"
        struct C{};
    \end{verbatim}
    После препроцессинга A будет определён в двух единицах трансляции, что может привести к UB. Для защиты от такого существует \textbf{include-guard}, который не позволяет заинклудить больше 1 раза. Он весьма прост.
    \begin{verbatim}
        // foo.h
        #ifndef FOO_H
        #define FOO_H
        struct foo{
            int a;
            void bar();
        };
        #endif
    \end{verbatim}
    Здесь во время препроцессинга будет проводиться проверка - определён ли идентификатор макроса FOO\_H. Если он не определён - он определяется, а содержимое
    успешно присоединяется к файлу. Если попробовать присоединить второй раз, то идентификатор FOO\_H уже будет определён и if не сработает, препроцессор пропустит весь код до \texttt{\#endif}
    и таким образом избежит второго определения структуры. \nl
    Альтернатива: тупо вставить \texttt{\#pragma once} в начало хэдера.

    \section{Лекции 9/10}
\subsection{Классы, функции члены-класса, this}
    Классы в С++ $-$ структура с методами, конструктором и деструктором.\nl
    Функции члены-класса $-$методы.\nl
    Экземпляр класса $-$ объект.\nl
    \begin{verbatim}
        struct IntArray {
            explicit IntArray(size_t size) : size(size), data(new int[size]) {
                for (size_t i = 0; i < size; ++i) {
                    data[i] = 0;
                }
            }
            ~IntArray() {
                delete[] data;
            }
            int & get(size_t i) {
                return data[i];
            }
            size_t size;
            int *data;
        };
        ...
        IntArray a(10); // объект
        IntArray b = {20, new int[20]}; // ошибка, для инициализации теперь есть конструктор
        IntArray *c = new IntArray(10); // указатель на объект в динамической памяти
    \end{verbatim}
    \texttt{this} $-$ константный указатель(?), являющийся \texttt{rvalue}, присутствующий неявно в каждом
    методе класса. Вместо \texttt{data} можно использовать \texttt{this->data}.
  \subsection{Модификаторы доступа}
    Модификаторы доступа $-$ ключевые слова, нужные для изменения возможности доступа к данным в классе.
    \nl
    Существуют 3 таких модификатора: \texttt{public}, \texttt{private} и \texttt{protected}. Первый означает, что у
    внешних функций есть доступ к данным класса, второй $-$наоборот не даёт доступа никому, а последний $-$как
    \texttt{private}, только доступ есть у наследников.\nl
    \begin{verbatim}
        struct IntArray {
            ... // <- здесь находятся public данные
         private:
            size_t size;
            int *data;
        };
    \end{verbatim}
    Для структур (\texttt{struct}) по умолчанию стоит \texttt{public}, а для классов (\texttt{class}) $-$\texttt{private}.
  \subsection{Ссылки}
  Ссылки $-$специфические константные указатели.\nl
  Сравнение ссылок и указателей:\nl
  1) ссылка не может быть неинициализированной. \nl \texttt{int \&l; // CE}\nl
  2) у ссылки нет нулевого значения. \nl \texttt{int \&l = 0; // CE}\nl
  3) ссылку нельзя переинициализировать. \nl \texttt{int \&l = a; l = b; // на самом деле произошло a = b}\nl
  4) нельзя получить адрес ссылок и ссылку на ссылку. \nl \texttt {int \&l = a; int *pl = \&l; // получили ссылку на a} 
  \nl \texttt{int \&\&l = l; // CE} \nl
  5) нельзя создавать массив ссылок (так как ссылки обязательно нужно инициализировать)\nl
  6) нет арифметики для ссылок\nl
  Важный момент: указатели и ссылки могут указывать только на lvalue.
  \subsection{Чем отличается структура от класса?}
  Поля структуры по дефолту публичные, у класса поля по дефолту приватные. \newpage
  \subsection{Конструкторы и деструкторы}
  Функция-поле, имя которой совпадает с именем класса, использующаяся для инициализации объектов класса,
  называется \textbf{конструктором}. Есть и обратная функция, которая вызывается неявно, по завершении жизни объекта, об этом чуть ниже.
  Такая функция называется \textbf{деструктором}. Он не может принимать какие-либо аргументы.
  \begin{verbatim}
      struct PVector{
          int* data;
          PVector(size_t a){
              if (a <= 0)
                throw std::runtime_error("incorrect size");
              data = (int*) malloc(a*sizeof(int));
          } // конструктор
          void set(size_t ind, int a){
              data[ind] = a;
          }
          ~PVector(){
              free(data);
          } // деструктор, автоматически освобождает память
      }

      int main(){
          PVector a; // CE
          PVector a(12); // OK
          PVector a(-2); // RTE, которую мы устроили сами
          PVector b = PVector(777); // OK
      }
  \end{verbatim}
  Про \texttt{explicit} конструкторы написано в 6й лекции.
  \subsection{storage classes \& object lifetime}
  Существует три класса памяти.
  \begin{enumerate}
      \item Автоматическая память - переменные/параметры функций размещаются в ней (то есть в стеке). Эта память
      выделяется при вызове функции и освобождается при возвращении управления туда, где её вызвали.
      \item Статическая память - там лежат переменные из глобальной области видимости, а также static-переменные в функциях и классах. Линковщик выделяет эту память до запуска программы.
      \item Динамическая память - ну тут и так понятно. Там хранятся созданные через \texttt{new} объекты. Удаление/выделение на плечах программиста.
  \end{enumerate}
  Время жизни объекта определяется областью видимости и классом памяти. 
  \begin{itemize}
      \item Локальные (они же автоматические) объекты рождаются в момент их определения и умирают на выходе из области видимости.
      \item Объекты в неймспейсах, а также статики создаются до $main()$ и уничтожаются после $main()$.
      \item Локальные статические объекты (например, статики в функциях) создаются в момент определения и уничтожаются после $main()$.
      \item Объекты в динамической памяти создаются во время \texttt{new}, уничтожаются во время \texttt{delete}.
      \item Временные объекты (это то, что появляется, например, в \texttt{bigint a = b + c}) создаются подвыражением и уничтожаются по завершении полного выражения (полное не является подвыражением другого выражения).
      Если временная переменная связана с какой-то ссылкой - она будет жить, пока жива ссылка. Пример:
  \end{itemize}
  \begin{verbatim}
      std::vector<int> a = {1, 2, 3};
      void get(int q) return a[q];

      void func(){
          const string &link = get(0);
          string qqq = get(2);
      }
      // временная строка из get(0) живёт до конца func.
      // временная строка из get(2) уничтожается после инициализации qqq.
  \end{verbatim}
  (Перегрузку операторов пропустил - и так понятно, как в джаве.) \nl
  \subsection{Специальные функции-члены класса}
  \subsubsection{Конструктор по умолчанию}
  Если в классе \textbf{не определён ни один конструктор}, то тогда будет создан конструктор по умолчанию. Он не имеет тела и не принимает аргументов. Очевидно, что их можно перегружать.
  \subsubsection{Деструктор}
  Вызывается при уничтожении объекта, не может принимать аргументов, по умолчанию ничего не делает.
  По окончании работы деструктора будут неявно вызваны деструкторы всех не-статических членов класса. Деструкторы нельзя перегрузить.
  \subsubsection{Конструктор копирования}
  Рассмотрим \texttt{PVector} из 4.5. Что будет, если мы создадим один вектор и присвоим его другому? Оба указателя $data$ будут ссылаться на одну и ту же область памяти!
  А это значит, что если поменять какое-нибудь значение в $v_2$ при помощи $set$, оно поменяется и в $v_1$. А ещё есть риск двойного удаления. Очень жаль. \nl
  Конструктор копирования по умолчанию сгенерируется, если он не определён в коде (а ещё - если в классе нет виртуальной дичи(11/12)).
  Как легко догадаться, дефолтный конструктор копирования делает тупейшее битовое копирование.
  Синтаксис конструктора копирования: \texttt{PVector (const PVector\&)}. В случае с нашим \texttt{PVector} мы можем переопределить так - 
  выделить память у нового объекта (то есть указатель на данные будет другим) и сделать уже туда тупой memcpy. \nl
  \textbf{NB:} Можно вообще запретить копирование объектов - определить конструктор копирования и засунуть его в приватную область. \newpage
  \subsubsection{Оператор присваивания}
  Вернёмся к \texttt{PVector}. Хоть код \texttt{PVector a = v2; PVector b(v1);} стал безопасен (здесь $v_1, v_2$ это ранее созданные \texttt{PVector}), 
  код \texttt{b = a;} всё ещё представляет угрозу. Здесь ещё и новая катастрофа - будет очевидная утечка (кто освободит память в $b$?)
  Дефолтный оператор присваивания работает по аналогии с дефолтным конструктором копирования. Его синтаксис:
  \texttt{PVector\& operator=(const PVector\& other)}. А чтобы пофиксить \texttt{PVector} потребуется не только аккуратно выделить память/скопировать, но и освободить старую память. В конце оператора присваивания
  (не обязательно \texttt{PVector}) следует сделать \texttt{return *this;} (внимание на то, что возвращает оператор).
  \subsection{deleted functions}
  Выше было указано, как можно запретить копирование объектов. Начиная с C++11 есть более изящный метод, как это сделать:
  \begin{verbatim}
      struct foo{
          foo();
          foo(const foo& a) = delete; // запрещено копирование
          foo& operator=(const foo& a) = delete; // запрещено присваивание
          void *operator new(std::size_t) = delete;
          void *operator new[](std::size_t) = delete; // запрещён оператор new
          void bar(int) = delete; // запрещён автоматический каст
          void bar(double);
      }
  \end{verbatim}
  Кроме того, на удалённые функции нельзя создавать указатели. Всё отсеивается на этапе компиляции.
  \subsection{new/delete/malloc/free}
  Общее у этих выражений - они выделяют/освобождают динамическую память соответственно. Отличия:
  \begin{itemize}
      \item new в случае неудачи кинет исключение, malloc вернёт $nullptr$.
      \item new вызывает конструктор и выделяет память (или только конструктор, если это placement new). malloc только выделяет память.
      \item аналогично: delete вызовет деструктор, free только освободит память.
      \item $new$ берёт память из \sout{epic} free store, $malloc$ - из heap. По сути, это две различных области памяти. В одной то, что выделено $new$, в другой то, что выделено $malloc$.
      Это одна из причин, почему \texttt{fsanitize}, связанные с памятью, очень сильно горят на попытку сделать $free$ к памяти, выделенной $new$ и наоборот.
  \end{itemize}
  Отличие \texttt{new/delete} от \texttt{new[] / delete[]}: \nl
  $new$ выделит память и вызовет конструктор для одного объекта, $delete$ - освободит и позовёт деструктор для одного объекта соответственно. \nl
  $new[]$ выделит память и вызовет конструкторы каждого объекта для массива объектов, $delete$ - освободит и позовёт деструкторы для каждого элемента в массиве объектов соответственно. \nl
  \newpage
  UB в new/delete:
  \begin{itemize}
      \item \texttt{new[]}, но \texttt{delete}.
      \item \texttt{ptr = new[]; delete[] (ptr + c)} (c - константа).
      \item (подробнее в 19): \texttt{ptr = new derived[666]; delete static\_cast<base*>(ptr);}.
  \end{itemize}

  \section{Лекции 11/12}
  \textbf{Никитос, с богом.}
\end{document}
    