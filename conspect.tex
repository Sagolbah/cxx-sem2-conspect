\documentclass[15pt, a4paper]{article}
\usepackage[utf8]{inputenc} % если ваш файл содержит русский текст, нужно указать кодировку
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel} % для того, чтобы писать русский текст
\usepackage{amsmath} % для команды equation*
\usepackage{hyperref} % для вставки ссылок
\usepackage{graphicx}
\usepackage[russian]{babel}
\parindent 0pt
\parskip 0pt
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{array}
\usepackage[left=2.3cm, right=3.3cm, top=1.7cm, bottom=1.7cm, bindingoffset=0cm]{geometry}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{float}
\usepackage{enumitem}
\usepackage{array}
\usepackage{subcaption}
\usepackage{multicol}
\usepackage{fancyhdr} 
\usepackage{extramarks}
\usepackage{todonotes}
\usepackage{color}
\graphicspath{{pictures/}}
\usepackage{lipsum}                     % Dummytext
\usepackage{xargs}                      % Use more than one optional parameter in a new commands
\usepackage{xcolor}

\usepackage{setspace}
\onehalfspacing

\title{C++ year2018, семестр 2}
\author{github.com/Sagolbah/cxx-sem2-conspect}
\date{\today}

\pagestyle{fancy}
\fancyhf{}
\lhead{Нужны контрибьюты!}
\chead{C++ y2018 sem2}
\rhead{\thepage}
\lfoot{github.com/Sagolbah/cxx-sem2-conspect}
\cfoot{}
\rfoot{\today}
\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}
\newcommand{\nl}{\newline}
\newcommand{\intba}{\int^b_a}


\setenumerate{topsep=0ex,itemsep=0ex,partopsep=0ex,parsep=0ex}

\begin{document}
	\section{Клуб фанатов Manowar}
	\begin{enumerate}
		\item Каждая секция - отдельная тема у Сорокина (sorokin.github.io/cpp-course).
		\item Для списков используйте \verb|\begin{enumerate}| или \verb|\begin{itemize}| 
		\item Очень помогает latex cheatsheet.
        \item Первые пять билетов пропущены - там асм и прочая дичь. Пока что в приоритете билеты по плюсам.
        \item Может попасться всё до 19 билета включительно.
        \item Писать максимально подробно по каждому пункту - мало ли, что могут спросить.
        \item ГачиБасс228.
    \end{enumerate}
 
    \section{Билет 6}
    \subsection{Структуры}
    С помощью структур можно создавать пользовательские типы. По дефолту все поля структуры публичны,
    в то время как поля классов по дефолту приватны. \nl
    Доступ к полям структур осуществляется через оператор $'.'$, для указателей на структуры используется
    оператор $'->'$.
    \begin{verbatim}
        struct point {
        	double x;
            double y;
        };
        ...
        point p = {11.4514, 810.931};
        p.x = -19.19;
        point * pp = new point;
        pp->y = 4545;
    \end{verbatim}
    Инициализировать структуры можно, прописав фигурные скобки. \nl
    Методы $-$ функции, определяемые в полях структур (non C-style). Они  реализованы с неявным параметром
    $this$, который является указателем на текущий экземпляр структуры.
    Объявдение и определение методов:
    \begin{verbatim}
    	struct point {
        	// declaration
        	void shift(double x, double y);
        	double x;
            double y;
        };
        ...
        // definition
        void point::shift(double x, double y) {...}        
    \end{verbatim}
    Определение структуры не генерирует никакого кода на ассемблере. Структуры существуют только на
    момент компиляции, они определяют то, как данные адресуются в памяти и располагаются, но после того,
    как код скомпилировался, никакой информации о структурах уже нет. \nl
    Конструкторы $-$ методы для инициализации структур.
    \begin{verbatim}
        	point() {x = y=  0;}
            point(double x, double y) {
            	this->x = x;
                this->y = y;
            }
        ...
        // empty constructor call
        point p1;
        // calling constructor with 2 args
        point p2 = point(1, 2);
    \end{verbatim}
    Список инициализации позволяет проинициализировать поле до входа в тело конструктора. Инициализация
    полей в списке инициализации происходит в порядке объявления полей. То есть при написании $y(0), x(y)$
    произойдёт не то, что ожидалось.
    \begin{verbatim}
        	point() : x(0), y(0) {}
            point(double x, double y) : x(x), y(y) {}
    \end{verbatim}
    В функциях можно определить значения по умолчанию.
    \begin{verbatim}
    	point(double x = 0, double y = 0) : x(x), y(y) {}
        ...
        point p1; // x = 0, y = 0
        point p2(2); // x = 2, y = 0
        point p3(3, 4); // x = 3, y = 4
    \end{verbatim}
    Конструктор одного параметра задаёт неявное пользовательское преобразование. Запретить это можно при
    помощи ключевого слова $explicit$.
    \begin{verbatim}
    	explicit point(double x = 0, double y = 0) : x(x), y(y) {}
        ...
        point p = 2; // error
    \end{verbatim}
    Конструктор по умолчанию генерируется компилятором, если он пользовательски не задан.
    \begin{verbatim}
    	struct segment {
        	segment(point p1, point p2) : p1(p1), p2(p2) {}
            point p1;
            point p2;
        };
        ...
        segment s; // error
    \end{verbatim}
    Деструктор $-$ метод, вызывающийся при удалении структуры и по умолчанию генерируется компилятором. У
    него может быть только 0 аргументов, и он всегда один на одну структуру. Объявляется как ~<struct name>. \nl
    Конструкторы и деструктор позволяют чётко определять время жизни структуры. Обращение к некоторым
    значениям до вызова конструктора или после вызова деструктора приводит к undefined behavior.
    \newpage
    \subsection{Указатели, адреса, массивы и их друзья}
    Память компьютера (спасибо SKKV'у) - это последовательность байтов, пронумерованных от $0$ до $2^n-1$. Всё, что в ней расположено,
    имеет свой адрес. Тип данных, хранящий адрес на объект типа $t$ называется указателем на $t$:
    \begin{verbatim}
        int a = 666;
        int *ptr = &a; // *a = 666, унарный & - оператор взятия адреса в памяти.      
    \end{verbatim} 
    Например, если наша переменная лежала в участке памяти, \textbf{первая} ячейка которого имеет номер $1337228$, указатель будет хранить число $1337228$.
    Из коммента к примеру видно, что унарный $*$ - это оператор разыменовывания. Кроме того, можно разыменовывать указатель и делать присваивание:
    \begin{verbatim}
        char ch = 'a', ch2 = 'q';
        char *ptr = &ch;
        char *ptr2 = &ch2;
        *ptr = 'b';  // OK, ch = 'b'.
        *ptr = *ptr2; // OK, ch = 'q', ch2 = 'q'
        int* fail = &ch2; // CE, нельзя присваивать int* char*
        int* rr = new int(8);
        delete rr;
        *rr = 111; // ОЖВП
    \end{verbatim}
    Массивы - это, по сути своей, последовательность объектов. Они расположены в соседствующих ячейках. В качестве синтаксического сахара существует оператор $[]$. \nl
    \textbf{NB:} размер массива определяется на этапе компиляции.
    \begin{verbatim}
        int arr[10];
        int* qqq = arr; // ОК, массив, по сути, это и есть указатель.
        arr[0] = 12, arr[1] = -15, arr[2] = 666;
        printf("%d", *arr); // напечатает первый элемент, указатель хранит именно его.
        *(arr + 2) = 20; // arr[2] = 20.
        arr[1] = 100;
        *(arr + 1) = 100; // это эквивалентный код. 
        arr[-1] = 1349; // i am not in danger, i AM the danger.
        // RTE такое не выкинет, осторожно!
        arr[5] = 88888;
        int *ptr = &arr[5]; // OK, указатели могут ссылаться на элементы массива.
        *ptr = 102; // OK, arr[5] = 102
    \end{verbatim}
    Из примера выше: в арифметике указателей не требуется домножать на $sizeof(type)$. Инкремент указателя на $int$, например, увеличит адрес
    на 4, а не на 1, так как $sizeof(int) = 4$. Декремент работает аналогично, но уменьшает адрес. Примеры с арифметикой: 
    \begin{verbatim}
        int arr[10];
        int *ptr = arr;
        *(++ptr) = 1214; // OK, arr[1] = 1214, внимание на приоритет операций.
        int *ptr2 = &arr[8];
        printf("%d", ptr2 - ptr); // OK, выведется 7.
        auto bye = ptr + ptr2; // CE, складывать нельзя.
        for (int *i = &arr[0]; i<&arr[10]; ++i) printf("%d ", *i); // OK, выведет arr.
    \end{verbatim}
    Ещё есть тип $*void$, он юзается для указателей на ячейку памяти, тип которой неизвестен. Пример юзания - передача адреса из одной части программы в другую. \nl
    Указатели на функции:
    \begin{verbatim}
        int foo(){
            return 102;
        }
        double square(double a){
            return a*a;
        }    
        int area(int a, int b){
            return a*b;
        }
        int (*ptr)() = foo; // OK. Внимание - тут неявная конвертация
        // NB: если бы у нас была ф-ия сортировки с аргументом - указатель на функцию 
        // компаратора (int* arr, bool (*comparator)(int, int))
        // и компаратор cmp где-нибудь сверху, можно было бы написать sort(arr, cmp);
        int (*ptr2)() = square; // CE, разные типы возврата
        double(*ptr2)() = square; // CE, не те аргументы
        double(*ptr2)(double) = square; // OK
        int (*ptr3)(int, int) = area; // OK
        // вызов функций:
        std::cout << (*ptr)() << "\n"; // 102
        std::cout << (*ptr2)(13.22) << "\n"; // 174.168
        std::cout << (*ptr3)(12, 22) << "\n"; // 264
    \end{verbatim}
    Такой уродский синтаксис обусловлен приоритетом операций. В противном случае код int *ptr() будет прочтён как предварительное объявление
    функции $ptr()$, которая ничего не принимает и возвращает указатель на $int$. \nl
    И немного о ссылках: это, по сути, автоматически разыменовываемый константный указатель.
    \begin{verbatim}
        int t = 10;
        int &link = t;
        link = 666; // t = 666
        int a = 124124;
        link = &a; // CE
    \end{verbatim}

\end{document}
    