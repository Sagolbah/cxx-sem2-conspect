\documentclass[15pt, a4paper]{article}
\usepackage[utf8]{inputenc} % если ваш файл содержит русский текст, нужно указать кодировку
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel} % для того, чтобы писать русский текст
\usepackage{amsmath} % для команды equation*
\usepackage{hyperref} % для вставки ссылок
\usepackage{graphicx}
\usepackage[russian]{babel}
\parindent 0pt
\parskip 0pt
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{array}
\usepackage[left=2.3cm, right=3.3cm, top=1.7cm, bottom=1.7cm, bindingoffset=0cm]{geometry}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{float}
\usepackage{enumitem}
\usepackage{array}
\usepackage{subcaption}
\usepackage{multicol}
\usepackage{fancyhdr} 
\usepackage{extramarks}
\usepackage{todonotes}
\usepackage{color}
\graphicspath{{pictures/}}
\usepackage{lipsum}                     % Dummytext
\usepackage{xargs}                      % Use more than one optional parameter in a new commands
\usepackage{xcolor}

\usepackage{setspace}
\onehalfspacing

\title{C++ year2018, семестр 2}
\author{github.com/Sagolbah/cxx-sem2-conspect}
\date{\today}

\pagestyle{fancy}
\fancyhf{}
\lhead{Нужны контрибьюты!}
\chead{C++ y2018 sem2}
\rhead{\thepage}
\lfoot{github.com/Sagolbah/cxx-sem2-conspect}
\cfoot{}
\rfoot{\today}
\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}
\newcommand{\nl}{\newline}
\newcommand{\intba}{\int^b_a}


\setenumerate{topsep=0ex,itemsep=0ex,partopsep=0ex,parsep=0ex}

\begin{document}
	\section{Клуб фанатов Manowar}
	\begin{enumerate}
		\item Каждая секция - отдельная тема у Сорокина (sorokin.github.io/cpp-course).
		\item Для списков используйте \verb|\begin{enumerate}| или \verb|\begin{itemize}| 
		\item Очень помогает latex cheatsheet.
        \item Первые пять билетов пропущены - там асм и прочая дичь. Пока что в приоритете билеты по плюсам.
        \item Может попасться всё до 19 билета включительно.
        \item Писать максимально подробно по каждому пункту - мало ли, что могут спросить.
        \item ГачиБасс228.
    \end{enumerate}
 
    \section{Билет 6}
    \subsection{Структуры}
    С помощью структур можно создавать пользовательские типы. По дефолту все поля структуры публичны,
    в то время как поля классов по дефолту приватны. \nl
    Доступ к полям структур осуществляется через оператор $'.'$, для указателей на структуры используется
    оператор $'->'$.
    \begin{verbatim}
        struct point {
        	double x;
            double y;
        };
        ...
        point p = {11.4514, 810.931};
        p.x = -19.19;
        point * pp = new point;
        pp->y = 4545;
    \end{verbatim}
    Инициализировать структуры можно, прописав фигурные скобки. \nl
    Методы $-$ функции, определяемые в полях структур (non C-style). Они  реализованы с неявным параметром
    $this$, который является указателем на текущий экземпляр структуры.
    Объявдение и определение методов:
    \begin{verbatim}
    	struct point {
        	// declaration
        	void shift(double x, double y);
        	double x;
            double y;
        };
        ...
        // definition
        void point::shift(double x, double y) {...}        
    \end{verbatim}
    Определение структуры не генерирует никакого кода на ассемблере. Структуры существуют только на
    момент компиляции, они определяют то, как данные адресуются в памяти и располагаются, но после того,
    как код скомпилировался, никакой информации о структурах уже нет. \nl
    Конструкторы $-$ методы для инициализации структур.
    \begin{verbatim}
        	point() {x = y=  0;}
            point(double x, double y) {
            	this->x = x;
                this->y = y;
            }
        ...
        // empty constructor call
        point p1;
        // calling constructor with 2 args
        point p2 = point(1, 2);
    \end{verbatim}
    Список инициализации позволяет проинициализировать поле до входа в тело конструктора. Инициализация
    полей в списке инициализации происходит в порядке объявления полей. То есть при написании $y(0), x(y)$
    произойдёт не то, что ожидалось.
    \begin{verbatim}
        	point() : x(0), y(0) {}
            point(double x, double y) : x(x), y(y) {}
    \end{verbatim}
    В функциях можно определить значения по умолчанию.
    \begin{verbatim}
    	point(double x = 0, double y = 0) : x(x), y(y) {}
        ...
        point p1; // x = 0, y = 0
        point p2(2); // x = 2, y = 0
        point p3(3, 4); // x = 3, y = 4
    \end{verbatim}
    Конструктор одного параметра задаёт неявное пользовательское преобразование. Запретить это можно при
    помощи ключевого слова $explicit$.
    \begin{verbatim}
    	explicit point(double x = 0, double y = 0) : x(x), y(y) {}
        ...
        point p = 2; // error
    \end{verbatim}
    Конструктор по умолчанию генерируется компилятором, если он пользовательски не задан.
    \begin{verbatim}
    	struct segment {
        	segment(point p1, point p2) : p1(p1), p2(p2) {}
            point p1;
            point p2;
        };
        ...
        segment s; // error
    \end{verbatim}
    Деструктор $-$ метод, вызывающийся при удалении структуры и по умолчанию генерируется компилятором. У
    него может быть только 0 аргументов, и он всегда один на одну структуру. Объявляется как ~<struct name>. \nl
    Конструкторы и деструктор позволяют чётко определять время жизни структуры. Обращение к некоторым
    значениям до вызова конструктора или после вызова деструктора приводит к undefined behavior.
\end{document}
    