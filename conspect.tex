\documentclass[15pt, a4paper]{article}
\usepackage[utf8]{inputenc} % если ваш файл содержит русский текст, нужно указать кодировку
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel} % для того, чтобы писать русский текст
\usepackage{amsmath} % для команды equation*
\usepackage{hyperref} % для вставки ссылок
\usepackage{graphicx}
\usepackage[russian]{babel}
\parindent 0pt
\parskip 0pt
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{array}
\usepackage[left=2.3cm, right=3.3cm, top=1.7cm, bottom=1.7cm, bindingoffset=0cm]{geometry}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{float}
\usepackage{enumitem}
\usepackage{array}
\usepackage{subcaption}
\usepackage{multicol}
\usepackage{fancyhdr} 
\usepackage{extramarks}
\usepackage{todonotes}
\usepackage{color}
\graphicspath{{pictures/}}
\usepackage{lipsum}                     % Dummytext
\usepackage{xargs}                      % Use more than one optional parameter in a new commands
\usepackage{xcolor}

\usepackage{setspace}
\onehalfspacing

\title{C++ year2018, семестр 2}
\author{github.com/Sagolbah/cxx-sem2-conspect}
\date{\today}

\pagestyle{fancy}
\fancyhf{}
\lhead{Нужны контрибьюты!}
\chead{C++ y2018 sem2}
\rhead{\thepage}
\lfoot{github.com/Sagolbah/cxx-sem2-conspect}
\cfoot{}
\rfoot{\today}
\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}
\newcommand{\nl}{\newline}
\newcommand{\intba}{\int^b_a}


\setenumerate{topsep=0ex,itemsep=0ex,partopsep=0ex,parsep=0ex}

\begin{document}
	\section{Клуб фанатов Manowar}
	\begin{enumerate}
		\item Каждая секция - отдельная тема у Сорокина (sorokin.github.io/cpp-course).
		\item Для списков используйте \verb|\begin{enumerate}| или \verb|\begin{itemize}| 
		\item Очень помогает latex cheatsheet.
        \item Первые пять билетов пропущены - там асм и прочая дичь. Пока что в приоритете билеты по плюсам.
        \item Может попасться всё до 19 билета включительно.
        \item Писать максимально подробно по каждому пункту - мало ли, что могут спросить.
        \item ГачиБасс228.
    \end{enumerate}
 
    \section{Билет 6}
    \subsection{Структуры}
    С помощью структур можно создавать пользовательские типы. По дефолту все поля структуры публичны,
    в то время как поля классов по дефолту приватны. \nl
    Доступ к полям структур осуществляется через оператор \texttt{.}, для указателей на структуры используется
    оператор \texttt{->}.
    \begin{verbatim}
        struct point {
        	double x;
            double y;
        };
        ...
        point p = {11.4514, 810.931};
        p.x = -19.19;
        point * pp = new point;
        pp->y = 4545;
    \end{verbatim}
    Инициализировать структуры можно, прописав фигурные скобки. \nl
    Методы $-$ функции, определяемые в полях структур (non C-style). Они  реализованы с неявным параметром
    \texttt{this}, который является указателем на текущий экземпляр структуры.
    Объявдение и определение методов:
    \begin{verbatim}
    	struct point {
        	// declaration
        	void shift(double x, double y);
        	double x;
            double y;
        };
        ...
        // definition
        void point::shift(double x, double y) {...}        
    \end{verbatim}
    Определение структуры не генерирует никакого кода на ассемблере. Структуры существуют только на
    момент компиляции, они определяют то, как данные адресуются в памяти и располагаются, но после того,
    как код скомпилировался, никакой информации о структурах уже нет. \nl
    Конструкторы $-$ методы для инициализации структур.
    \begin{verbatim}
        	point() {x = y=  0;}
            point(double x, double y) {
            	this->x = x;
                this->y = y;
            }
        ...
        // empty constructor call
        point p1;
        // calling constructor with 2 args
        point p2(1, 2);
    \end{verbatim}
    Список инициализации позволяет проинициализировать поле до входа в тело конструктора. Инициализация
    полей в списке инициализации происходит в порядке объявления полей. То есть при написании \texttt{y(0),
    x(y)} произойдёт не то, что ожидалось.
    \begin{verbatim}
        	point() : x(0), y(0) {}
            point(double x, double y) : x(x), y(y) {}
    \end{verbatim}
    В функциях можно определить значения по умолчанию.
    \begin{verbatim}
    	point(double x = 0, double y = 0) : x(x), y(y) {}
        ...
        point p1; // x = 0, y = 0
        point p2(2); // x = 2, y = 0
        point p3(3, 4); // x = 3, y = 4
    \end{verbatim}
    Конструктор одного параметра задаёт неявное пользовательское преобразование. Запретить это можно при
    помощи ключевого слова \texttt{explicit}.
    \begin{verbatim}
    	explicit point(double x = 0, double y = 0) : x(x), y(y) {}
        ...
        point p = 2; // error
    \end{verbatim}
    Конструктор по умолчанию генерируется компилятором, если он пользовательски не задан.
    \begin{verbatim}
    	struct segment {
        	segment(point p1, point p2) : p1(p1), p2(p2) {}
            point p1;
            point p2;
        };
        ...
        segment s; // error
    \end{verbatim}
    Деструктор $-$ метод, вызывающийся при удалении структуры и по умолчанию генерируется компилятором.
    У него может быть только 0 аргументов, и он всегда один на одну структуру. Объявляется как \texttt{\~<struct
    name>}.\nl
    Конструкторы и деструктор позволяют чётко определять время жизни структуры. Обращение к некоторым
    значениям до вызова конструктора или после вызова деструктора приводит к undefined behavior.
    \newpage
    \subsection{Указатели, адреса, массивы и их друзья}
    Память компьютера (спасибо SKKV'у) - это последовательность ячеек, пронумерованных от $0$ до $2^n-1$. Всё, что в ней расположено,
    имеет свой адрес. Тип данных, хранящий адрес на объект типа $t$ называется указателем на $t$:
    \begin{verbatim}
        int a = 666;
        int *ptr = &a; // *a = 666, унарный & - оператор взятия адреса в памяти.      
    \end{verbatim} 
    Например, если наша переменная лежала в участке памяти, \textbf{первая} ячейка которого имеет номер $1337228$, указатель будет хранить число $1337228$.
    Из коммента к примеру видно, что унарный $*$ - это оператор разыменовывания. Кроме того, можно разыменовывать указатель и делать присваивание:
    \begin{verbatim}
        char ch = 'a', ch2 = 'q';
        char *ptr = &ch;
        char *ptr2 = &ch2;
        *ptr = 'b';  // OK, ch = 'b'.
        *ptr = *ptr2; // OK, ch = 'q', ch2 = 'q'
        int* fail = &ch2; // CE, нельзя присваивать int* char*
        int* rr = new int(8);
        delete rr;
        *rr = 111; // ОЖВП
    \end{verbatim}
    Массивы - это, по сути своей, последовательность объектов. Они расположены в соседствующих ячейках. В качестве синтаксического сахара существует оператор $[]$. \nl
    \textbf{NB:} размер статического массива определяется на этапе компиляции.
    \begin{verbatim}
        int arr[10];
        int* qqq = arr; // ОК, массив, по сути, это и есть указатель.
        arr[0] = 12, arr[1] = -15, arr[2] = 666;
        printf("%d", *arr); // напечатает первый элемент, указатель хранит именно его.
        *(arr + 2) = 20; // arr[2] = 20.
        arr[1] = 100;
        *(arr + 1) = 100; // это эквивалентный код. 
        arr[-1] = 1349; // i am not in danger, i AM the danger.
        // RTE такое не выкинет, осторожно!
        arr[5] = 88888;
        int *ptr = &arr[5]; // OK, указатели могут ссылаться на элементы массива.
        *ptr = 102; // OK, arr[5] = 102
    \end{verbatim}
    Из примера выше: в арифметике указателей не требуется домножать на $sizeof(type)$. Инкремент указателя на $int$, например, увеличит адрес
    на 4, а не на 1, так как $sizeof(int) = 4$. Декремент работает аналогично, но уменьшает адрес. Примеры с арифметикой: 
    \begin{verbatim}
        int arr[10];
        int *ptr = arr;
        *(++ptr) = 1214; // OK, arr[1] = 1214, внимание на приоритет операций.
        int *ptr2 = &arr[8];
        printf("%d", ptr2 - ptr); // OK, выведется 7.
        auto bye = ptr + ptr2; // CE, складывать нельзя.
        for (int *i = &arr[0]; i<&arr[10]; ++i) printf("%d ", *i); // OK, выведет arr.
    \end{verbatim}
    Ещё есть тип $*void$, он юзается для указателей на ячейку памяти, тип которой неизвестен. Пример юзания - передача адреса из одной части программы в другую. \nl
    Указатели на функции:
    \begin{verbatim}
        int foo(){
            return 102;
        }
        double square(double a){
            return a*a;
        }    
        int area(int a, int b){
            return a*b;
        }
        int (*ptr)() = foo; // OK. Внимание - тут неявная конвертация
        // NB: если бы у нас была ф-ия сортировки с аргументом - указатель на функцию 
        // компаратора (int* arr, bool (*comparator)(int, int))
        // и компаратор cmp где-нибудь сверху, можно было бы написать sort(arr, cmp);
        int (*ptr2)() = square; // CE, разные типы возврата
        double(*ptr2)() = square; // CE, не те аргументы
        double(*ptr2)(double) = square; // OK
        int (*ptr3)(int, int) = area; // OK
        // вызов функций:
        std::cout << (*ptr)() << "\n"; // 102
        std::cout << (*ptr2)(13.22) << "\n"; // 174.168
        std::cout << (*ptr3)(12, 22) << "\n"; // 264
    \end{verbatim}
    Такой уродский синтаксис обусловлен приоритетом операций. В противном случае код int *ptr() будет прочтён как предварительное объявление
    функции $ptr()$, которая ничего не принимает и возвращает указатель на $int$. \nl
    И немного о ссылках: это, по сути, автоматически разыменовываемый константный указатель.
    \begin{verbatim}
        int t = 10;
        int &link = t;
        link = 666; // t = 666
        int a = 124124;
        link = &a; // CE
    \end{verbatim}
    \newpage

    \section{Билеты 7/8}
    \subsection{Процесс компиляции программ}
    \begin{enumerate}
        \item Препроцессинг. \nl
        На этой стадии происходит работа с директивами препроцессора. Например, \texttt{\#include}, \texttt{\#define}, \texttt{\#ifndef}.    
        Хэдеры, включённые через \texttt{\#include} проходят препроцессинг рекурсивно. При помощи флага $-E$ можно получить файл без компиляции, но с препроцессингом. \nl
        \texttt{g++ -E A.cpp -o A.ii} - здесь A.ii это .cpp файл после препроцессинга.
        \item Получение ассемблерного кода. \nl
        Здесь плюсовый код превращается в ассемблерный (но ещё не машинный). При помощи флага $-S$ можно получить ассемблерный код:
        \texttt{g++ -S A.cpp -o A.s}
        \item Получение машинного кода. \nl
        Здесь тексты на языке ассемблера превращаются в объектные файлы. Объектный файл содержит кусок машинного кода, который ещё не связан с остальными кусками кода в единую программу.
        Простейший пример - определение полей класса в одном файле, а объявление - в другом. Именно для объединения их и существует следующая стадия.
        Получить машинный код с помощью асма AT\&T можно так: \texttt{as A.s -o A.o}
        \item Линковка. \nl
        Здесь все объектные файлы и статические либы связываются в единый исполняемый файл, который мы и используем.
        Для линковки используется таблица символов. Это генерируемая компилятором структура данных, хранящая имена функций, объектов итд,
        где каждому идентификатору (символу) соотносятся его тип и область видимости. В ней также хранятся адреса ссылок на данные и прочее в других объектных файлах
        Благодаря этой таблице линковщик строит связи между данными в различных оюъектных файлах, собирая из них единый исполняемый файл / библиотеку. \nl
        \textbf{NB:} Единицей трансляции называется подаваемый на вход компилятору исходник со всеми включёнными в него файлами. Судя по англовики, это то, что получается после первой стадии.
    \end{enumerate}
    \subsection{declaration/definition}
    Объявление вводит переменную/функцию в область видимости, устанавливает её тип и, опционально, инициализирует её.
    Пока имя не объявлено, его использовать, очевидно, нельзя. Объявление, которое полностью описывает объявлённую сущность (переменная/функция/etc) называется определением.
    \begin{verbatim}
        double square(double); // declaration функции
        extern int tmp; // declaration (defined by garbage value)
        int def = 98; // declaration (and definition)
        int square(double); // очевидный CE.
        
        double square(double k){
            return k*k;
        } // definition of declared "square"

        // cycling:

        double f(int a){
            return g(a-1) - 44;
        }

        double g(int a){
            if (a > 1) return f(a-29) + 151;
            return 9;
        }   // цикл определений, чтобы спастись, нужно заранее объявить функции
        // struct def/decl:

        struct point;

        struct point {int x; int y;};

        struct cycle{
            cycle a; // CE
            cycle *a; // OK
        };
    \end{verbatim}
    \subsection{static, headers, header-guard (карты, деньги, два ствола)}
    Модификатор \texttt{static} работает как в жаве - это \textbf{общее} поле для всех экземпляров класса. Можно обратиться извне (если публичный) при помощи двух двоеточий.
    Использование $static$ по отношению к члену класса гарантирует, что в программе будет ровно одна копия его значения (а не по копии на каждый объект).
    Статические переменные создаются и инициализируются только один раз, а после выхода из области видимости - не сгорают. Тем не менее, к ним можно обратиться только из их области видимости.
    \begin{verbatim}
        void foo(){
            static int a = 1;
            ++a;
            printf("%d\n", a);
        }
        int main(){
            foo(); // 2
            foo(); // 3
            foo(); // 4
            a = 666; // CE, нет в области видимости.
        }
    \end{verbatim}
    Заголовки позволяют программисту контролировать определения и объединения. В хэдерах записывают объявления, а затем их можно помещать при помощи $\# include$.
    В С++ принята следующая практика (на примере): в $sample.h$ файле собраны объявления, а $sample.cpp$ - инклудит хэдер и определяет поля. Например, в $calc.h$ объявлена
    функция $ln$, а в $.cpp$ - эта функция реализуется. Позже в другом файле сделать \texttt{\#include "sample.h"} и пользоваться той же функцией $ln$. \nl 
    Однако, есть одна проблема. Директивка \texttt{\#include} тупо копипастит содержимое другого файла в исходник. Поэтому может возникнуть такое:
    \begin{verbatim}
        // A.cpp
        struct A{
            void foo();
        };
        // B.cpp
        #include "A.cpp"
        struct B{};
        // C.cpp
        #include "A.cpp"
        struct C{};
    \end{verbatim}
    После препроцессинга A будет определён в двух единицах трансляции, что может привести к UB. Для защиты от такого существует \textbf{include-guard}, который не позволяет заинклудить больше 1 раза. Он весьма прост.
    \begin{verbatim}
        // foo.h
        #ifndef FOO_H
        #define FOO_H
        struct foo{
            int a;
            void bar();
        };
        #endif
    \end{verbatim}
    Здесь во время препроцессинга будет проводиться проверка - определён ли идентификатор макроса FOO\_H. Если он не определён - он определяется, а содержимое
    успешно присоединяется к файлу. Если попробовать присоединить второй раз, то идентификатор FOO\_H уже будет определён и if не сработает, препроцессор пропустит весь код до \texttt{\#endif}
    и таким образом избежит второго определения структуры. \nl
    Альтернатива: тупо вставить \texttt{\#pragma once} в начало хэдера.

    \section{Билет 9/10}
\subsection{Rлассы, функции члены-класса, this}
    Классы в С++ $-$ структура с методами, конструктором и деструктором.\nl
    Функции члены-класса $-$методы.\nl
    Экземпляр класса $-$ объект.\nl
    \begin{verbatim}
        struct IntArray {
            explicit IntArray(size_t size) : size(size), data(new int[size]) {
                for (size_t i = 0; i < size; ++i) {
                    data[i] = 0;
                }
            }
            ~IntArray() {
                delete[] data;
            }
            int & get(size_t i) {
                return data[i];
            }
            size_t size;
            int *data;
        };
        ...
        IntArray a(10); // объект
        IntArray b = {20, new int[20]}; // ошибка, для инициализации теперь есть конструктор
        IntArray *c = new IntArray(10); // указатель на объект в динамической памяти
    \end{verbatim}
    \texttt{this} $-$ константный указатель(?), являющийся \texttt{rvalue}, присутствующий неявно в каждом
    методе класса. Вместо \texttt{data} можно использовать \texttt{this->data}.
  \subsection{Модификаторы доступа}
    Модификаторы доступа $-$ ключевые слова, нужные для изменения возможности доступа к данным в классе.
    \nl
    Существуют 3 таких модификатора: \texttt{public}, \texttt{private} и \texttt{protected}. Первый означает, что у
    внешних функций есть доступ к данным класса, второй $-$наоборот не даёт доступа никому, а последний $-$как
    \texttt{private}, только доступ есть у наследников.\nl
    \begin{verbatim}
        struct IntArray {
            ... // <- здесь находятся public данные
         private:
            size_t size;
            int *data;
        };
    \end{verbatim}
    Для структур (\texttt{struct}) по умолчанию стоит \texttt{public}, а для классов (\texttt{class}) $-$\texttt{private}.
  \subsection{Ссылки}
  Ссылки $-$специфические константные указатели.\nl
  Сравнение ссылок и указателей:\nl
  1) ссылка не может быть неинициализированной. \nl \texttt{int \&l; // CE}\nl
  2) у ссылки нет нулевого значения. \nl \texttt{int \&l = 0; // CE}\nl
  3) ссылку нельзя переинициализировать. \nl \texttt{int \&l = a; l = b; // на самом деле произошло a = b}\nl
  4) нельзя получить адрес ссылок и ссылку на ссылку. \nl \texttt {int \&l = a; int *pl = \&l; // получили ссылку на a} 
  \nl \texttt{int \&\&l = l; // CE} \nl
  5) нельзя создавать массив ссылок (так как ссылки обязательно нужно инициализировать)\nl
  6) нет арифметики для ссылок\nl
  Важный момент: указатели и ссылки могут указывать только на lvalue.\nl
  \begin{verbatim}
    this is not end!
  \end{verbatim}
\end{document}
    